## ТЗ: Плагин «Ассистент» для Obsidian

Цель: плагин-ассистент, который помогает не пропускать встречи календаря, предлагает записывать встречи, делает транскрибацию и ведёт карточки людей (досье).

### 0) Платформа (scope)

- Сейчас делаем **только для Linux**.
- Кроссплатформенность (macOS/Windows) — **не в текущем scope**, можно вернуться позже.

### 0) Уровни автоматизации (контекст)

- **Операционный уровень**: календарь, встречи, запись, транскрибация, напоминания (всё “здесь и сейчас”).
- **Тактический уровень**: выполнение задач, внедрение/программирование, поддержка нескольких проектов параллельно.
- **Стратегический уровень**: экономия времени/денег, поиск возможностей, рост дохода за счёт автоматизации.

### 0) Термины

- **Календарь**: источник встреч (Google Calendar / CalDAV / ICS / др.).
- **Встреча (Event)**: запись в календаре с временем начала/конца, названием, участниками, ссылкой.
- **Протокол (Protocol)**: карточка/артефакты конкретной встречи/разговора (запись, транскрипт, саммари, факты и т.д.), которая может (или не может) быть связана со встречей в календаре.
- **Запись**: аудиофайл разговора (локально).
- **Транскрипт**: текст с таймингами, участниками и аналитикой.
- **Карточка человека**: заметка/страница в Obsidian + метаданные (факты/голос/источники).
- **Карточка проекта**: заметка/страница в Obsidian, которая агрегирует встречи/решения/факты/участников вокруг одной цели.

---

## 1) Календарь

### 1.1. Подключение календарей (источники)

Требования:

- Поддержать подключение нескольких календарей.
- Источники:
  - **Google Calendar** (OAuth2, выбор календарей).
  - **Другие**: CalDAV (Nextcloud, iCloud), ICS URL, локальный .ics.
- У каждого календаря должны быть: имя, тип, статус (вкл/выкл), цвет, правила синхронизации.
- Для MVP-1 используем **ICS URL (приватные ссылки с токеном)**, т.к. нужно иметь возможность обновлять описание встречи (добавлять саммари).

Результат в UI:

- В настройках список календарей + управление ими (добавить/удалить/вкл/выкл/настройки доступа).

### 1.2. Панель календаря

Требования:

- В Obsidian должна быть отдельная панель (View) с отображением календаря.
- Режимы: день/неделя/повестка (agenda).
- Клик по встрече открывает карточку встречи (или заметку-сводку по ней).
- В панели должно быть **видно текущее время** (линия/индикатор “сейчас”) и **приближающие встречи**.
- Повестка (MVP): показываем **один день**:
  - кнопки **← день назад**, **Сегодня**, **день вперёд →**.

Минимально (MVP):

- Повестка на сегодня/завтра + список ближайших встреч.

### 1.3. Уведомления по встречам (попапы)

Требования:

- За **5 минут до начала** встречи показывать pop-up:
  - название встречи, время, календарь, участники (если есть), кнопки: “Открыть”, “Отложить”, “Игнорировать”.
- В момент **начала встречи** показывать pop-up “Встреча началась”.
- Исключить дубль-уведомления (если Obsidian перезапускался).
- Учитывать часовой пояс, переносы, отмены.

Настройки:

- Уведомления должны быть **настраиваемыми**:
  - глобально включить/выключить,
  - порог (по умолчанию 5 минут), дополнительно “в момент начала”,
  - режим “не беспокоить” (окна времени),
  - per-calendar настройки (вкл/выкл, цвет/фильтры),
  - действия по кнопкам (поведение “Отложить” и список вариантов).

Реализация (текущая):

- Единый способ: **electron_window** (встроенное окно поверх всех) — всегда используем его.
- Safety: если `BrowserWindow` недоступен в окружении (тесты/нестандартный runtime), делаем fallback на **Obsidian `Notice`**.

### 1.4. Метаданные встреч: какие данные нужны, как визуализировать, интеграции

Цель: данные календаря напрямую влияют на:

- отображение в “Повестке” (приоритет/цвет/статусы),
- создание и обновление карточек людей,
- создание/навигацию по протоколам,
- (в будущем) обратную запись саммари/ссылок в календарь.

#### 1.4.1. Какие данные нам нужны (минимум/опционально)

- **Идентичность встречи (обязательно)**:
  - `calendar_id`, `event_id`
  - для повторений: `recurrence_id` (если есть) + `rrule/exdate` (для развёртки)
  - `sequence` / `last_modified` (если есть) — для корректного обновления/конфликтов
- **Время (обязательно)**:
  - `start`, `end`, `all_day`, часовой пояс (`TZID` если есть)
- **Отображение (желательно)**:
  - `summary`
  - `status` (confirmed/cancelled/tentative)
  - `visibility/class` (private/public) — влияет на то, что можно сохранять в vault
  - `calendar_color` (из настроек календаря) + `event_color` (если провайдер даёт)
  - `categories/labels` (если доступны) — как теги/метки в UI
- **Ссылки и контент (желательно)**:
  - `location`
  - `url` + дополнительные URL, извлечённые из `description` (Meet/Zoom/Документы/Трекер)
  - `description` (как “сырьё” для извлечения ссылок/контекста)
- **Люди (критично для карточек людей)**:
  - `organizer` (email + displayName)
  - `attendees[]`: email + displayName + `role` + `partstat` (accepted/declined/…)
  - “мой статус” (`my_partstat`) по `settings.calendar.myEmail`
  - если email отсутствует — создавать временного “Собеседник N” и давать UI для последующего мерджа

#### 1.4.2. Как и где это визуализировать

- **Повестка (таймлайн/сетка)**:
  - цвет встречи: (пока не реализовано; позже будет `event_color`)
  - бейджи статуса: `Принято/Отклонено/Возможно/Нет ответа`, `отменена`, `приватная`
  - быстрые иконки/линки: “есть ссылка Meet/Zoom”, “есть документы”, “есть протоколы”
  - tooltip/подробности по hover: организатор, участники (N), список ссылок
  - контекстное меню: перейти во встречу, открыть текущий/последний протокол, создать новый протокол
- **Карточка встречи (md в vault)**:
  - frontmatter (машинные поля): `calendar_id`, `event_id`, `start/end`, `status`, `organizer`, `attendees`, `labels`, `event_color`
- frontmatter (доп.): `timezone`, `rrule`, `reminders_minutes_before`
  - машинные секции:
    - “Протоколы” (links)
    - “Ссылки” (нормализованный список URL, извлечённый из description/location/url)
    - “Участники” (ссылки на People карточки, где возможно)
  - пользовательская секция: заметки/контекст
- **Карточка протокола (md)**:
  - ссылка на встречу (обратно)
  - “Участники” — ссылки на People карточки; на их основе позже строим voiceprint/диаризацию

#### 1.4.3. Как взаимодействуем с календарём (источники) — варианты и trade-offs

- **Фасад (интерфейс) календаря — чтобы избежать vendor lock**
  - В коде вводим единый интерфейс провайдера календаря (например `CalendarProvider`):
    - `refresh()` → вернуть список встреч (Event) за горизонт
    - нормализация полей (event_id/start/end/attendees/status/colors/links)
  - `CalendarService` становится “оркестратором”, который:
    - хранит кеш встреч,
    - вызывает нужного провайдера по `calendar.type`,
    - отдаёт единый формат данных для UI/Sync/Notifications.
  - Это позволяет:
    - сегодня использовать `ics_url`,
    - завтра добавить `caldav`,
    - при необходимости — `google_api`,
    - не меняя UI/Sync слой.

- **ICS URL (MVP-1/сейчас)**:
  - **Плюсы**: просто, быстро, работает почти везде, хорошо для read-only синка.
  - **Минусы**: обычно **read-only** (нельзя обновлять описание), ограничения по метаданным (цвет/лейблы/статусы могут быть неполными), сложности с TZID/RECURRENCE-ID, нет надёжных push-обновлений.
  - **Вывод**: отлично для чтения и повестки; для “записать саммари в календарь” почти всегда нужен другой канал.
- **CalDAV (WebDAV)**
  - **Плюсы**: стандарт, часто **read/write**, подходит для Nextcloud/iCloud/других серверов, можно обновлять описание/поля встречи.
  - **Минусы**: сложнее настройка (авторизация, URL, discovery), реализация протокола/конфликтов/ETag, нюансы разных серверов.
  - **Вывод**: лучший “универсальный” путь для write-back без привязки к Google.
  - Реализация в плагине: через библиотеку `tsdav` (discovery + загрузка встреч через CalDAV REPORT time-range).
  - Для Google: поддерживаем **OAuth (refresh token)** вместо Basic (loopback callback на `127.0.0.1`).
  - **Нюансы (практика, Google CalDAV)**:
    - `serverUrl` должен быть **строго** `https://apidata.googleusercontent.com/caldav/v2/` (без email). Иначе discovery может падать с `cannot find homeUrl` или давать “пустые” результаты.
    - В Google Cloud проекте для OAuth Client ID нужно включить **CalDAV API** (а не только “Google Calendar API”). Типичная ошибка при выключенном API: `accessNotConfigured` (403).
    - Discovery обычно возвращает несколько календарей (основной и “Праздники”). Для встреч нужен основной календарь (displayName ≈ email).
    - Неверный `calendarUrl` (опечатка/устаревший URL) может давать **0 событий без исключения** → лучше переподключать календарь через discovery.
- **Google Calendar API**
  - **Плюсы**: максимум метаданных (цвет/лейблы/организатор/участники/статусы), хорошая поддержка повторений, удобный write-back (вставить саммари/ссылку на протокол).
  - **Минусы**: OAuth2, хранение токенов, настройка проекта Google, потенциально “тяжелее” в поддержке, vendor lock-in.
  - **Вывод**: лучший путь для Google-аккаунта, особенно если write-back обязателен.

Рекомендуемый план по этапам:

- **MVP**: читаем через ICS URL + визуализация/протоколы/люди (из email).
- **Write-back**: добавляем один из каналов (CalDAV или Google API) только для календарей, где нужен write-back (саммари/ссылки).

---

## 2) Запись встречи

### 2.1. Детект “сейчас идёт встреча”

Требования:

- Определять, что идёт встреча/разговор:
  - по **запущенным приложениям** (Zoom/Chrome вкладка Meet/Телемост/Teams/и т.д.)
  - по **активности звуковой карты** (наличие речи/голоса/уровень).
- Если обнаружен разговор — показывать pop-up с кнопкой **“Записать”**.
- Можно использовать готовый плагин **«Диктофон»** (как backend записи), либо собственную запись (если плагин не подходит).

Ограничения/заметки:

- В Obsidian-плагине JS нет прямого доступа (в рамках Linux) к списку процессов/аудиоустройствам без:
  - внешнего helper-сервиса (локальный демон) + IPC/HTTP,
  - или использования специфичных API ОС.
    Это нужно учесть в архитектуре (см. раздел 5).

### 2.2. Предложение записи + автостарт по таймеру

Требования:

- Если запись не идёт — предлагать записать.
- Pop-up содержит обратный отсчёт **5…4…3…2…1…** и **автоматически стартует запись**, если пользователь не отменил.
- Кнопки: “Записать сейчас”, “Отмена”, “Не предлагать N минут”, “Настройки”.

### 2.3. Привязка к встрече календаря (желательно)

Требования:

- Если “идёт встреча” и есть ближайшая встреча в календаре (± X минут) — предложить привязать запись к встрече.
- Если встреча содержит ссылку (Meet/Zoom) — повышать уверенность матчинга.
- После обработки записи встречи (получены транскрипт/саммари) — предложить:
  - **обновить встречу в календаре**,
  - добавить в описание/заметки **саммари для календаря** (короткий формат),
  - приложить ссылку на заметку встречи в Obsidian (если возможно).

---

## 3) Транскрибация записи

### 3.1. Базовая расшифровка (строгая)

Требования:

- Транскрипт с:
  - **таймингами** (timecodes)
  - **спикерами** (Speaker A/B/… или реальные имена при наличии)
  - максимально “дословно” (без перефразирования)
- Хранить ссылку на исходную запись.
- Если найден **новый спикер**:
  - автоматически создать карточку в `People/` вида **“Собеседник 1”**, **“Собеседник 2”** и т.д.;
  - дать UI для заполнения имени/фамилии/деталей;
  - после переименования карточки, по “слепку голоса” спикер должен **обновляться во всех связанных заметках** (идентификатор спикера остаётся стабильным, отображаемое имя меняется).

### 3.2. Саммари разговора

Требования:

- Краткое резюме.
- Структура: контекст → решения → риски/блокеры → следующие шаги.
- Саммари может быть несколько (минимум):
  - **максимально краткое**,
  - **для календаря** (очень короткое, без лишних деталей),
  - **расширенное для Obsidian**,
  - **с аналитикой**, опираясь на базу Obsidian (связанные проекты/люди/контекст прошлых встреч).

### 3.3. Извлечение фактов/обещаний/утверждений

Требования:

- Выделять:
  - факты (что произошло/известно),
  - обещания/коммитменты (кто что сделает),
  - решения,
  - задачи/экшены,
  - вопросы/неопределённости.
- Для каждого элемента: источник (фраза/таймкод), участник, уверенность.
- Извлечённые факты/обещания должны **привязываться к людям и проектам**:
  - ссылка на `People/...` (кто сказал/кому адресовано),
  - ссылка на `Projects/...` (в рамках какого проекта),
  - хранить обратные связи (из карточки человека/проекта видно связанные факты и встречи).

### 3.4. Эмоциональная окраска

Требования:

- Оценка тона:
  - по участникам (реплики),
  - по всему разговору.
- Метрики: нейтральный/напряжённый/позитивный и т.п. (настраиваемый набор).

### 3.5. Участники + “слепок голоса” (voiceprint)

Требования:

- Извлекать список участников:
  - из календаря (attendees),
  - из речи/обращений (если возможно),
  - вручную подтвердить/исправить в UI.
- Делать “слепок голоса” для каждого участника, чтобы позже определять автоматически.
  - хранить безопасно (хэш/эмбеддинг), версионировать.
  - предусмотреть согласие/конфиденциальность (важно).

---

## 4) Ведение карточек (люди / проекты)

### 4.1. Карточка (структура)

Требования:

- На карточке человека хранить:
  - базовые данные (имя, компания, роли),
  - контакты (может быть несколько значений каждого типа):
    - телефоны (личный/рабочий/другое),
    - email (личный/рабочий),
    - ссылки (LinkedIn/Telegram/сайт/портфолио),
    - ссылка/ссылки на резюме (CV),
  - “досье” (сводка),
  - связи (проекты/встречи),
  - извлечённые факты/обещания/конфликты/интересы.
- Формат: markdown-файл в vault + frontmatter (YAML) для ключевых полей.

### 4.2. Хранение “хэшей голоса”

Требования:

- Хранить voiceprint для автодетекта.
- Привязка voiceprint ↔ карточка человека.
- Возможность обновлять/объединять/удалять voiceprint.

### 4.3. Обогащение из внешних и закрытых источников

Требования:

- Уметь “обогащать” карточку:
  - ручной импорт (текст/ссылки),
  - интеграции (в будущем) — CRM, почта, мессенджеры, приватные базы.
- Важно: фиксировать источники и дату обновления.

### 4.4. Карточка проекта (структура и сценарии)

Требования:

- Карточка проекта хранит:
  - цель/описание проекта,
  - статус (idea/active/on-hold/done), приоритет,
  - ключевые участники (ссылки на People),
  - встречи и протоколы (ссылки на Protocols/Calendar),
  - решения, договорённости, обещания (с источниками и датами),
  - факты/риски/следующие шаги.
- Формат: markdown-файл в vault + frontmatter (YAML) для ключевых полей.
- Сценарии:
  - из заметки встречи можно “привязать к проекту” (выбор существующего или создание нового),
  - проектная сводка строится из связанных встреч/фактов (как “хронология”).

---

## 5) Настройки (Settings UI)

### 5.0. Папки в vault (настраиваемые)

Требования:

- В настройках должно быть управление папками хранения (по умолчанию во множественном числе):
  - `Ассистент/Встречи/`
  - `Ассистент/Протоколы/`
  - `Ассистент/Люди/`
  - `Ассистент/Проекты/`
- Эти пути должны быть **настраиваемыми**, т.к. пользователь может захотеть другой layout vault.

Примечание:

- Лог‑файлы специально **не храним в vault**, чтобы не засорять хранилище.
- Логи лежат в системной папке плагина: `<vault>/.obsidian/plugins/assistant/logs/`.

### 5.1. Календарь

- Подключения: список календарей.
- Политики синхронизации: период, частота, кеширование, оффлайн.
- Уведомления: “за N минут”, “в момент начала”, DND.
- Автообновление:
  - включить/выключить,
  - интервал (например, каждые 5/10/15/30 минут),
  - ручная кнопка “Обновить сейчас”.

### 5.2. Запись

- Вкл/выкл детект встреч.
- Источник детекта: процессы / аудио / гибрид.
- Автостарт записи: вкл/выкл, таймер.
- Интеграция с “Диктофон”: выбор режима (если доступно).

### 5.3. Транскрибация/AI

- Провайдер: локально / облако.
- Язык(и).
- Форматы вывода: транскрипт/саммари/факты/эмоции.
- Интеграция с Obsidian Copilot (если доступно): использовать как движок/провайдера (через его API или через общие файлы/команды).

---

## 6) Данные и хранение

### 6.1. Где хранить

- **Obsidian vault**: markdown заметки (встречи/протоколы/люди/проекты).
- **Папка плагина**: технические файлы (кеш календарей, индексы, voiceprint, настройки).

### 6.1.1. Приватность и локальность (нефункциональные требования)

Требования:

- Vault синхронизируется через **приватный git-репозиторий** (и доступен на телефоне).
- На старте допускается **облачная обработка** (AI/ASR/voiceprint) — всё должно быть явным: провайдер, ключи, что отправляется, логирование, возможность отключить.
- В перспективе возможен переход на **локальную обработку** (время/опыт покажет).
- Учитывать git-sync → не складывать тяжёлые бинарники в git без необходимости.

### 6.2. Политика хранения записей (аудио)

Требования:

- После успешной обработки записи (получены: транскрипт, тайминги, спикеры/voiceprint, факты/саммари и т.д.) **аудиофайл можно удалять**.
- Должны быть настройки ретенции:
  - “Удалять аудио сразу после успешной обработки” (по умолчанию: **вкл**),
  - “Хранить N дней” (опционально),
  - “Никогда не удалять” (если нужно для контроля качества).
- В заметке протокола хранить:
  - метаданные обработки,
  - ссылки на результаты,
  - (опционально) путь к аудио, если оно не удалено.

### 6.3. Git-синхронизация (важно)

Требования:

- Vault синхронизируется через **приватный git**, но аудиофайлы записей всё равно **желательно не коммитить** (большие бинарники).
- Рекомендуемые стратегии:
  - хранить записи **вне vault** (в папке плагина/вне git), а в vault сохранять только транскрипт/саммари/факты;
  - или хранить временно и удалять после обработки (см. 6.2).

### 6.4. Предлагаемая структура в vault (черновик)

- `Meetings/` — встречи (по дате).
- `People/` — карточки людей.
- `Projects/` — карточки проектов.
- `Calendar/` — заметки встреч (опционально).

Также для плагина создаются папки (внутри vault) — **по умолчанию** (и это настраивается в Settings):

- `Ассистент/Встречи/` — встречи календаря (md файлы). Клик по встрече в “Повестке” открывает файл встречи.
  - Повторяющиеся встречи (например “Планёрка”) живут **в одном файле** (стабильно по `(calendar_id, event_id)`).
- `Ассистент/Люди/` — карточки людей (md файлы).
- `Ассистент/Проекты/` — карточки проектов (md файлы).
- `Ассистент/Протоколы/` — протоколы конкретных встреч (md файлы), например “Планёрка 19 января”.

Лог‑файлы (вне vault):

- `<vault>/.obsidian/plugins/assistant/logs/` — логи по датам (например `2026-01-20.log`).

### 6.5. Сущности и связи (база данных в markdown)

Модель:

- **Встреча (Calendar Event)** → хранится в `Ассистент/Встречи/` (1 запись = 1 “тип” встречи, включая повторяющиеся по UID).
- **Протокол (Protocol)** → хранится в `Ассистент/Протоколы/` (каждая конкретная встреча: “Планёрка 19 января”).
- **Связь**: **Встреча 1 → N Протоколов** (одна встреча может иметь много протоколов).
- **Из протокола извлекаются**: **Люди** (`Ассистент/Люди/`) и **Проекты** (`Ассистент/Проекты/`).

Правила:

- При **обновлении календарей** плагин **не должен создавать прошедшие** встречи в `Ассистент/Встречи/` (чтобы не засорять vault).
- Исключение: если пользователь **перешёл во встречу из UI** (клик по встрече) — файл встречи может быть создан **on-demand** даже для прошедшей даты.
- В файле встречи должна быть секция **“Протоколы”** со ссылками на связанные заметки протоколов.
- В заметке протокола должны быть: ссылка на запись (если есть), транскрипт, саммари (несколько форматов), извлечённые факты/обещания/задачи и ссылки на людей/проекты.

Правила именования файлов:

- Файлы **встреч** должны быть:
  - **человекочитаемые** (название встречи в начале),
  - но при этом **стабильные** при переименовании встречи.
  - Практика: имя файла = `"{summary} [{sid}].md"`, где:
    - стабильный ключ = `calendar_id:event_id` (вычисляется из frontmatter),
    - `sid` — короткий стабильный идентификатор, вычисляемый из стабильного ключа (в имени файла вместо `event_id/calendar_id`).
  - При изменении `summary` плагин может **переименовать файл**, чтобы имя оставалось красивым (идентичность держим через `(calendar_id, event_id)`).
- Файлы **протоколов** должны иметь **человекочитаемые имена** (с пробелами), например: “Техническая встреча с Партнёром”.
- В имени файла **не используем** `event_id` и `calendar_id` (идентичность держим в frontmatter).
- В свойствах (frontmatter) протокола обязательно хранить:
  - `protocol_id` (= `calendar_id:event_id`)
  - `calendar_id`
- Если имя файла конфликтует (файл уже существует) — добавлять суффикс: ` 2`, ` 3`, ` 4` и т.д.

---

## 7) Архитектура (важно для реальности)

### 7.0. Разделение слоёв (Sync vs UI)

Требования:

- UI (повестка/лог) не должен содержать “тяжёлую” логику синхронизации.
- Синхронизация календарей, запись в vault, планирование уведомлений — отдельный слой (например `SyncService`), чтобы:
  - проще тестировать,
  - проще расширять (встречи/люди/проекты),
  - ошибки синка не ломали UI.

### 7.1. Что можно сделать чисто в Obsidian-плагине

- UI панели календаря.
- Планировщик уведомлений по синхронизированным встречам.
- Создание/обновление заметок в vault.
- Вызов AI через HTTP (если есть ключи/endpoint) или через локальный сервис.
- Панель “Лог” (внутренние записи плагина).

### 7.2. AI-стек (локально/облако) и интеграция с Copilot

Требования:

- На старте используется **облачный AI-стек** (быстрее запустить).
- Позже (если будет смысл) добавить **локальные модели**:
  - Ollama (локальный inference),
  - или LM Studio (локальный OpenAI-совместимый сервер).
- Должна быть возможность использовать **единый OpenAI-compatible endpoint** (например, Continue server или аналог) для:
  - Obsidian (через Copilot),
  - IDE/CLI (вне плагина).
- В ТЗ это отражаем как “провайдер AI”:
  - `local-openai-compatible` (localhost),
  - `cloud-openai-compatible` (опционально).

### 7.2. Что требует внешнего компонента (helper)

Для Linux (в текущем scope) надёжно:

- список активных приложений/окон/URL вкладки,
- доступ к аудиоустройствам/детект речи,
- запись системного аудио/микрофона (устойчиво),
- voiceprint/спикер-диаризация (часто через ML-библиотеки).

Решение:

- локальный **helper-сервис** (демон) + простой протокол:
  - `GET /status` (есть ли встреча),
  - `POST /record/start|stop`,
  - `POST /transcribe`,
  - `GET /devices`,
  - `GET /processes` (опционально).

### 7.3. Офлайн-встречи и мобильный сценарий

Требования:

- Должен быть сценарий **офлайн-встреч** (не Zoom/Meet): запись с микрофона/телефона.
- На телефоне есть vault (git-sync), поэтому возможен поток:
  - **запись на телефоне** (в vault или рядом),
  - **синхронизация через git**,
  - **обработка на компьютере** после синхронизации (саммари/факты/участники/привязки).

### 7.4. Внешние сервисы на старте (ASR/voiceprint)

Требования:

- Скорее всего на старте для:
  - распознавания речи (ASR),
  - диаризации/спикеров,
  - “слепков голоса” (voiceprint),
    используются **внешние сервисы**, а затем возможен переход на локальные решения (по мере опыта/готовности).

---

## 8) MVP-этапы (рекомендуемый порядок)

### MVP-0 ✅

- Команда и pop-up в Obsidian.

### MVP-1: Календарь (минимально)

- Подключение через ICS URL (самый простой старт).
- Панель “Повестка”.
- Уведомления за 5 минут и в момент начала.
- Автообновление календарей по интервалу.
- Панель “Лог” (минимально: обновили календари/показали уведомление/ошибка).

### MVP-2: Запись (минимально)

- Только ручной старт записи (кнопка в попапе/команда).
- Сохранение аудио + создание заметки встречи.

### MVP-3: Транскрибация (минимально)

- Один провайдер (например, локальный или облачный) + генерация заметки с транскриптом и саммари.

### MVP-4: Люди

- Карточки людей + ручное связывание с репликами/встречами.

### MVP-5: Тактический/стратегический слой

- Сбор задач/обещаний из встреч в проекты.
- Базовые отчёты/планы (оперативные/тактические/стратегические) на базе Obsidian.

---

## 9) Первые задачи для реализации в этом репозитории

1. Добавить Settings-экран (пока stub) + хранение настроек.
2. Добавить “Calendar: ICS URL” (скачивание + парсинг + кеш).
3. Добавить View “Agenda”.
4. Добавить планировщик уведомлений (5 минут/старт).
5. Добавить сущность “Protocol note” и базовый шаблон заметки.
6. Добавить сущность “Project note” (шаблон) + привязку Protocol → Project (минимально: поле/ссылка).
7. Добавить настройки “AI provider” (локальный OpenAI-compatible endpoint) и сохранение параметров провайдера.

# Справочник эмоциональной окраски

| Прилагательное       | Color   |
| :------------------- | :------ |
| Агрессивный          | #DC143C |
| Враждебный           | #8B0000 |
| Запугивающий         | #800000 |
| Критичный            | #B22222 |
| Обвиняющий           | #B22222 |
| Оборонительный       | #CD5C5C |
| Радикальный          | #8B0000 |
| Угрожающий           | #8B0000 |
| Апатичный            | #B0B0B0 |
| Безразличный         | #696969 |
| Отстраненный         | #C0C0C0 |
| Пассивный            | #D3D3D3 |
| Холодный             | #ADD8E6 |
| Ироничный            | #BA55D3 |
| Насмешливый          | #9370DB |
| Пассивно-агрессивный | #9ACD32 |
| Саркастичный         | #8A2BE2 |
| Саркастичный         | #8A2BE2 |
| Убедительный         | #9932CC |
| Язвительный          | #9400D3 |
| Беспокойный          | #FF8C69 |
| Жалобный             | #DDA0DD |
| Обеспокоенный        | #FFA07A |
| Пессимистичный       | #778899 |
| Презрительный        | #A9A9A9 |
| Раздраженный         | #FF6347 |
| Вовлеченный          | #FFA500 |
| Заинтересованный     | #FFD700 |
| Любопытный           | #FFB347 |
| Энтузиазм            | #FFD700 |
| Благодарный          | #98FB98 |
| Восторженный         | #FFD700 |
| Дружелюбный          | #32CD32 |
| Одобряющий           | #90EE90 |
| Оптимистичный        | #FFEC8B |
| Эйфоричный           | #FFFF00 |
| Прощающий            | #AFEEEE |
| Деловой              | #000080 |
| Официальный          | #191970 |
| Формальный           | #00008B |
| Заискивающий         | #FFFACD |
| Неуверенный          | #F5DEB3 |
| Напористый           | #FF4500 |
| Настойчивый          | #FF6347 |
| Прямолинейный        | #FF7F50 |
| Решительный          | #FF0000 |
| Требовательный       | #FF2400 |
| Уверенный            | #FF8C00 |
| Фанатичный           | #DC143C |
| Энергичный           | #FFA500 |
| Настороженный        | #F0E68C |
| Подозрительный       | #DAA520 |
| Скептический         | #F4A460 |
| Скрытный             | #DEB887 |
| Скептический         | #F4A460 |
| Скрытный             | #DEB887 |
| Уклончивый           | #F0E68C |
| Конструктивный       | #20B2AA |
| Открытый             | #87CEEB |
| Примирительный       | #48D1CC |
| Сочувствующий        | #87CEFA |
| Сочувствующий        | #87CEFA |
| Тактичный            | #6495ED |
| Ясный                | #1E90FF |
| Сдержанный           | #808080 |
| Снисходительный      | #5F9EA0 |
| Предупредительный    | #2F4F4F |
| Снисходительный      | #5F9EA0 |
| Учительский          | #008B8B |

# Заметки

Рефакторинг и максимально доделать повестку и календарь

- [x] Логи вынести в системную папку /home/gernovich/notes/.obsidian/plugins/assistant/logs, чтобы снизить шум и лишние файлы в хранилище (настройка логов не нужна)
- [x] Сделать ротацию логов, точнее ограничение хранения, например 7 дней, это должно настраиваться.
- [x] Кэширование данных календаря: offline-first “stale режим” + persistent cache (после рестарта тоже показываем last-good)
- [x] Название встречи — человеческое; идентичность держим через `(calendar_id, event_id)`, а при изменении summary делаем безопасный rename (суффиксы/конфликты не ломают связь)
- [x] Офлайн режим (MVP): очередь изменений (outbox). Если не получилось записать в vault — действие кладём в очередь + пишем причину в лог; есть кнопка “Применить очередь”.
- [x] В css использовать цвета, отстопы и другие элементы с не конкретные значения в переченные обсидиана, это даст консистентность интерфейса.
- [x] Нужно проработать поля карточек: что хранить, что отображать в базе, какие представления есть в базе
- [x] Из календаря, извлечение информации об участниках в карточки
- [x] Отмечать встречи Да (да в переговорке, да виртуально) / Нет / Может быть / Нет выбора (одно или последующие события)
- [x] Визуально что бы встречи отличались от Приду / Не приду / ...
- [x] Визуально цветные события из календаря
- [x] Отметка во встрече кто придет кто нет а кто ничего не указал

Звук

- [x] Алерт‑напоминание сделать красивым через electron_window как окно настроек обсидиана, чтобы не смотрелось костылём. Можно добавить чуть‑чуть прозрачности.
- [x] При любом всплывающем алерте не должно быть фокуса на клавишах, иначе если в момент печатать — он откроется и можно случайно быстро его закрыть
- [x] Кнопка записи разговора, на панели
- [x] Диалог записи разговора: 1) выбор события, по умолчанию если есть событие менее 5 минут (первое напоминание) то оно выбрано, или уже идёт, иначе — галочка «Новый протокол». 2) Круглая зелёная кнопка «Записать».
- [x] Если включить запись, то кнопка меняется на красную стоп. Выбор события или новый протокол не активны, показан процесс записи: гистограмма, также видны тайминги, количество файлов, и если идёт процесс расшифровки (мы пишем файлы блоками по N минут, это в настройках) — видно сколько файлов расшифровали.
- [x] Термины в UI: используем **“Расшифровано”** (вместо “Распознано”), “До конца блока” (вместо “До файла”).
- [x] В диалоге напоминания кнопка «Создать протокол» не нужна
- [x] В напоминании кнопкам [Начать запись], [Встреча отменена] и [Закрыть] добавить иконки, а для «Закрыть» — красную outline‑рамку.
- [x] Если в настройках включена авто‑запись и указан тайминг (по умолчанию 5 секунд), в диалоге записи если встреча идёт — показываем, что авто‑запись начнётся, и обратный отсчёт.
- [x] Окно диктофона или напоминания должны перетаскиваться за заголовок
- [x] Запись звука: сделать отдельными файлами по N минут, чтобы уже во время встречи получать расшифровку, факты, проекты и т.д. Главное — не дожидаться окончания.
- [x] Окно диктофона встречи со статистикой (Длительность, записано файлов, расшифровано файлов, найдено проектов/фактов/людей и т.д.)
- [x] Файлы с записями складываем в Ассистент/Записи
- [x] Улучшить систему логирования
- [x] Протоколы точно а может быть и другие сущности лучше раскладывать по папкам, например протоколы по папкам с именм встречи, а протоколы без встречи ложить в корень.
- [x] Сделать временную панель и окно отработки WindowTransport, и на нем отработать технологию.
- [x] Добавить логирование в ключевые места (Лишние убрать)
- [x] Логирование, установить необходимые сообщения и удалить лишние. Основная задача что если что то пошло не так можно было быстро сориентироваться где проблема и уже точечно залогировать.
- [x] В карточке встречи добавить участников (attendees + агрегаты в frontmatter)
- [x] Транспорт диалогов: MessageChannelTransport, по коду используется только абстракция WindowTransport
- [x] Для индикатора записи сделать умный нормализатор/буфер (RecordingVizNormalizer): принимает события с любой частотой, отдаёт с нужной; нормализует амплитуду; логирует статистику с заданной частотой; при тишине снижает значение и держит полосу на нуле. Компонент тестируемый, покрыт тестами, без вынесения настроек в конфиг.
  - [x] Отлаживаем Electron Media Devices, сейчас индикатор пустой
  - [x] Отлаживаем Linux Native, сейчас индикатор пустой
- [x] Ribbon: лог/отладка. Кнопка лога должна добавляться только после чтения настроек и с учётом `debug.enabled` (по умолчанию скрыта).
- [x] Удаляем тестовую панель Test window transport а также все связанное, диалог, стили и т.д. можно поискать по префиксу.

- [ ] Запись звука через [gst-kit](https://github.com/repugraf/gst-kit)
  - [ ] Убираем в настройках ffmpeg (linux_native) и все связнное с ним
  - [ ] Добавляем g_streamer (GStreamer) добавляем проверку зависимостей
  - [ ] В настройках определение устройство микрофона (ваш голос) авто или выбор из текущих + индикатор уровня для проверки + выбор фильтра на канал "none" | "normalize" | "voice"
  - [ ] В настройках определение устройство монитора (вы слышите) авто или выбор из текущих + индикатор уровня для проверки + выбор фильтра на канал "none" | "normalize" | "voice"
  - [ ] Добавляем бэкенд для gst, в диалог передаем два уровня громкости, микрофона и монитора
  - [ ] Рефакторим Electron Media Devices отдает только один уровень записи, микрофон (желтым).
  - [ ] В диалоге Диктофона на индикаторе рисуем два графика, микрофон (желтым) и монитор (синим)
  - [ ] Пишем файл не в tmp а в нужное место
  - [ ] Обновить документаци про зависимости, в целом можно взять от сюда https://github.com/repugraf/gst-kit


- [ ] Детектирование звука и запущенногго софта (Zoom) и всплывание окна диктофона, если понятно что это встреча, то обратный отчет с авто записью. (В конфиге авто запись и кол-во секунд по умолчанию включено и 5 секунд)

- [ ] Ревью всего проекта и особенно записи звука, повестки, настроек, DTO, поиск точек улучшения (см. REVIEW.md)

Тест/Прод

[ ] Добавить тестовый vault
[ ] Сделать инсталяцию плагина в тестовый и продовский vault

Расшифровка

- [ ] Локальный сервис Whisper / Внешние сервисы
- [ ] Транскрибация разговоров
- [ ] Диаризация спикеров: локальный / внешний
- [ ] Отпечаток голоса
- [ ] Эмоциональная окраска фразы и собеседников
- [ ] Обещание
- [ ] Факт

[ ] Тесты
[ ] Ручное тестирование
[ ] Ревью Расшифровки

Подключение LLM Свой чатик (CHAT.md)

[ ] Тесты
[ ] Ручное тестирование
[ ] Ревью ассистента
