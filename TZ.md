## ТЗ: Плагин «Ассистент» для Obsidian

Цель: плагин-ассистент, который помогает не пропускать встречи календаря, предлагает записывать встречи, делает транскрибацию и ведёт карточки людей (досье).

### 0) Платформа (scope)
- Сейчас делаем **только для Linux**.
- Кроссплатформенность (macOS/Windows) — **не в текущем scope**, можно вернуться позже.

### 0) Уровни автоматизации (контекст)
- **Операционный уровень**: календарь, встречи, запись, транскрибация, напоминания (всё “здесь и сейчас”).
- **Тактический уровень**: выполнение задач, внедрение/программирование, поддержка нескольких проектов параллельно.
- **Стратегический уровень**: экономия времени/денег, поиск возможностей, рост дохода за счёт автоматизации.

### 0) Термины
- **Календарь**: источник встреч (Google Calendar / CalDAV / ICS / др.).
- **Встреча (CalendarEvent)**: запись в календаре с временем начала/конца, названием, участниками, ссылкой.
- **Протокол (Protocol)**: карточка/артефакты конкретной встречи/разговора (запись, транскрипт, саммари, факты и т.д.), которая может (или не может) быть связана со встречей в календаре.
- **Запись**: аудиофайл разговора (локально).
- **Транскрипт**: текст с таймингами, участниками и аналитикой.
- **Карточка человека**: заметка/страница в Obsidian + метаданные (факты/голос/источники).
- **Карточка проекта**: заметка/страница в Obsidian, которая агрегирует встречи/решения/факты/участников вокруг одной цели.

---

## 1) Календарь

### 1.1. Подключение календарей (источники)
Требования:
- Поддержать подключение нескольких календарей.
- Источники:
  - **Google Calendar** (OAuth2, выбор календарей).
  - **Другие**: CalDAV (Nextcloud, iCloud), ICS URL, локальный .ics.
- У каждого календаря должны быть: имя, тип, статус (вкл/выкл), цвет, правила синхронизации.
- Для MVP-1 используем **ICS URL (приватные ссылки с токеном)**, т.к. нужно иметь возможность обновлять описание встречи (добавлять саммари).

Результат в UI:
- В настройках список календарей + управление ими (добавить/удалить/вкл/выкл/настройки доступа).

### 1.2. Панель календаря
Требования:
- В Obsidian должна быть отдельная панель (View) с отображением календаря.
- Режимы: день/неделя/повестка (agenda).
- Клик по встрече открывает карточку встречи (или заметку-сводку по ней).
- В панели должно быть **видно текущее время** (линия/индикатор “сейчас”) и **приближающие встречи**.
- Повестка (MVP): показываем **один день**:
  - кнопки **← день назад**, **Сегодня**, **день вперёд →**.

Минимально (MVP):
- Повестка на сегодня/завтра + список ближайших встреч.

### 1.3. Уведомления по встречам (попапы)
Требования:
- За **5 минут до начала** встречи показывать pop-up:
  - название встречи, время, календарь, участники (если есть), кнопки: “Открыть”, “Отложить”, “Игнорировать”.
- В момент **начала встречи** показывать pop-up “Встреча началась”.
- Исключить дубль-уведомления (если Obsidian перезапускался).
- Учитывать часовой пояс, переносы, отмены.

Настройки:
- Уведомления должны быть **настраиваемыми**:
  - глобально включить/выключить,
  - порог (по умолчанию 5 минут), дополнительно “в момент начала”,
  - режим “не беспокоить” (окна времени),
  - per-calendar настройки (вкл/выкл, цвет/фильтры),
  - действия по кнопкам (поведение “Отложить” и список вариантов).

Реализация (Linux, текущая):
- Способ доставки уведомления выбирается в Settings:
  - `obsidian_notice` — `Notice` внутри Obsidian
  - `system_notify_send` — системное уведомление через `notify-send` (требуется `libnotify-bin`)
  - `popup_window` — всплывающее окно через `yad` (требуется `yad`)
- Важно: **без fallback**. Если выбранный способ не работает (нет бинарника/ошибка запуска), пишем причину в лог и **уведомление не показываем**.
- Для UX добавлена кнопка **“Проверить зависимости”** (notify-send/yad) в настройках уведомлений.

### 1.4. Метаданные встреч: какие данные нужны, как визуализировать, интеграции

Цель: данные календаря напрямую влияют на:
- отображение в “Повестке” (приоритет/цвет/статусы),
- создание и обновление карточек людей,
- создание/навигацию по протоколам,
- (в будущем) обратную запись саммари/ссылок в календарь.

#### 1.4.1. Какие данные нам нужны (минимум/опционально)

- **Идентичность встречи (обязательно)**:
  - `calendar_id`, `uid`
  - для повторений: `recurrence_id` (если есть) + `rrule/exdate` (для развёртки)
  - `sequence` / `last_modified` (если есть) — для корректного обновления/конфликтов
- **Время (обязательно)**:
  - `start`, `end`, `all_day`, часовой пояс (`TZID` если есть)
- **Отображение (желательно)**:
  - `summary`
  - `status` (confirmed/cancelled/tentative)
  - `visibility/class` (private/public) — влияет на то, что можно сохранять в vault
  - `calendar_color` (из настроек календаря) + `event_color` (если провайдер даёт)
  - `categories/labels` (если доступны) — как теги/метки в UI
- **Ссылки и контент (желательно)**:
  - `location`
  - `url` + дополнительные URL, извлечённые из `description` (Meet/Zoom/Документы/Трекер)
  - `description` (как “сырьё” для извлечения ссылок/контекста)
- **Люди (критично для карточек людей)**:
  - `organizer` (email + displayName)
  - `attendees[]`: email + displayName + `role` + `partstat` (accepted/declined/…)
  - “мой статус” (`my_partstat`) по `settings.calendar.myEmail`
  - если email отсутствует — создавать временного “Собеседник N” и давать UI для последующего мерджа

#### 1.4.2. Как и где это визуализировать

- **Повестка (таймлайн/сетка)**:
  - цвет встречи: приоритет `event_color` → иначе `calendar_color`
  - бейджи: `принята/не отвечено/под вопросом/отклонена`, `отменена`, `приватная`
  - быстрые иконки/линки: “есть ссылка Meet/Zoom”, “есть документы”, “есть протоколы”
  - tooltip/подробности по hover: организатор, участники (N), список ссылок
  - контекстное меню: перейти во встречу, открыть текущий/последний протокол, создать новый протокол
- **Карточка встречи (md в vault)**:
  - frontmatter (машинные поля): `event_key`, `uid`, `calendar_id`, `start/end`, `status`, `organizer`, `attendees`, `labels`, `event_color`
  - машинные секции:
    - “Протоколы” (links)
    - “Ссылки” (нормализованный список URL, извлечённый из description/location/url)
    - “Участники” (ссылки на People карточки, где возможно)
  - пользовательская секция: заметки/контекст
- **Карточка протокола (md)**:
  - ссылка на встречу (обратно)
  - “Участники” — ссылки на People карточки; на их основе позже строим voiceprint/диаризацию

#### 1.4.3. Как взаимодействуем с календарём (источники) — варианты и trade-offs

- **Фасад (интерфейс) календаря — чтобы избежать vendor lock**
  - В коде вводим единый интерфейс провайдера календаря (например `CalendarProvider`):
    - `refresh()` → вернуть список встреч (CalendarEvent) за горизонт
    - нормализация полей (uid/start/end/attendees/status/colors/links)
  - `CalendarService` становится “оркестратором”, который:
    - хранит кеш встреч,
    - вызывает нужного провайдера по `calendar.type`,
    - отдаёт единый формат данных для UI/Sync/Notifications.
  - Это позволяет:
    - сегодня использовать `ics_url`,
    - завтра добавить `caldav`,
    - при необходимости — `google_api`,
    - не меняя UI/Sync слой.

- **ICS URL (MVP-1/сейчас)**:
  - **Плюсы**: просто, быстро, работает почти везде, хорошо для read-only синка.
  - **Минусы**: обычно **read-only** (нельзя обновлять описание), ограничения по метаданным (цвет/лейблы/статусы могут быть неполными), сложности с TZID/RECURRENCE-ID, нет надёжных push-обновлений.
  - **Вывод**: отлично для чтения и повестки; для “записать саммари в календарь” почти всегда нужен другой канал.
- **CalDAV (WebDAV)**
  - **Плюсы**: стандарт, часто **read/write**, подходит для Nextcloud/iCloud/других серверов, можно обновлять описание/поля встречи.
  - **Минусы**: сложнее настройка (авторизация, URL, discovery), реализация протокола/конфликтов/ETag, нюансы разных серверов.
  - **Вывод**: лучший “универсальный” путь для write-back без привязки к Google.
  - Реализация в плагине: через библиотеку `tsdav` (discovery + загрузка встреч через CalDAV REPORT time-range).
  - Для Google: поддерживаем **OAuth (refresh token)** вместо Basic (loopback callback на `127.0.0.1`).
  - **Нюансы (практика, Google CalDAV)**:
    - `serverUrl` должен быть **строго** `https://apidata.googleusercontent.com/caldav/v2/` (без email). Иначе discovery может падать с `cannot find homeUrl` или давать “пустые” результаты.
    - В Google Cloud проекте для OAuth Client ID нужно включить **CalDAV API** (а не только “Google Calendar API”). Типичная ошибка при выключенном API: `accessNotConfigured` (403).
    - Discovery обычно возвращает несколько календарей (основной и “Праздники”). Для встреч нужен основной календарь (displayName ≈ email).
    - Неверный `calendarUrl` (опечатка/устаревший URL) может давать **0 событий без исключения** → лучше переподключать календарь через discovery.
- **Google Calendar API**
  - **Плюсы**: максимум метаданных (цвет/лейблы/организатор/участники/статусы), хорошая поддержка повторений, удобный write-back (вставить саммари/ссылку на протокол).
  - **Минусы**: OAuth2, хранение токенов, настройка проекта Google, потенциально “тяжелее” в поддержке, vendor lock-in.
  - **Вывод**: лучший путь для Google-аккаунта, особенно если write-back обязателен.

Рекомендуемый план по этапам:
- **MVP**: читаем через ICS URL + визуализация/протоколы/люди (из email).
- **Write-back**: добавляем один из каналов (CalDAV или Google API) только для календарей, где нужен write-back (саммари/ссылки).

---

## 2) Запись встречи

### 2.1. Детект “сейчас идёт встреча”
Требования:
- Определять, что идёт встреча/разговор:
  - по **запущенным приложениям** (Zoom/Chrome вкладка Meet/Телемост/Teams/и т.д.)
  - по **активности звуковой карты** (наличие речи/голоса/уровень).
- Если обнаружен разговор — показывать pop-up с кнопкой **“Записать”**.
- Можно использовать готовый плагин **«Диктофон»** (как backend записи), либо собственную запись (если плагин не подходит).

Ограничения/заметки:
- В Obsidian-плагине JS нет прямого доступа (в рамках Linux) к списку процессов/аудиоустройствам без:
  - внешнего helper-сервиса (локальный демон) + IPC/HTTP,
  - или использования специфичных API ОС.
Это нужно учесть в архитектуре (см. раздел 5).

### 2.2. Предложение записи + автостарт по таймеру
Требования:
- Если запись не идёт — предлагать записать.
- Pop-up содержит обратный отсчёт **5…4…3…2…1…** и **автоматически стартует запись**, если пользователь не отменил.
- Кнопки: “Записать сейчас”, “Отмена”, “Не предлагать N минут”, “Настройки”.

### 2.3. Привязка к встрече календаря (желательно)
Требования:
- Если “идёт встреча” и есть ближайшая встреча в календаре (± X минут) — предложить привязать запись к встрече.
- Если встреча содержит ссылку (Meet/Zoom) — повышать уверенность матчинга.
- После обработки записи встречи (получены транскрипт/саммари) — предложить:
  - **обновить встречу в календаре**,
  - добавить в описание/заметки **саммари для календаря** (короткий формат),
  - приложить ссылку на заметку встречи в Obsidian (если возможно).

---

## 3) Транскрибация записи

### 3.1. Базовая расшифровка (строгая)
Требования:
- Транскрипт с:
  - **таймингами** (timecodes)
  - **спикерами** (Speaker A/B/… или реальные имена при наличии)
  - максимально “дословно” (без перефразирования)
- Хранить ссылку на исходную запись.
- Если найден **новый спикер**:
  - автоматически создать карточку в `People/` вида **“Собеседник 1”**, **“Собеседник 2”** и т.д.;
  - дать UI для заполнения имени/фамилии/деталей;
  - после переименования карточки, по “слепку голоса” спикер должен **обновляться во всех связанных заметках** (идентификатор спикера остаётся стабильным, отображаемое имя меняется).

### 3.2. Саммари разговора
Требования:
- Краткое резюме.
- Структура: контекст → решения → риски/блокеры → следующие шаги.
- Саммари может быть несколько (минимум):
  - **максимально краткое**,
  - **для календаря** (очень короткое, без лишних деталей),
  - **расширенное для Obsidian**,
  - **с аналитикой**, опираясь на базу Obsidian (связанные проекты/люди/контекст прошлых встреч).

### 3.3. Извлечение фактов/обещаний/утверждений
Требования:
- Выделять:
  - факты (что произошло/известно),
  - обещания/коммитменты (кто что сделает),
  - решения,
  - задачи/экшены,
  - вопросы/неопределённости.
- Для каждого элемента: источник (фраза/таймкод), участник, уверенность.
- Извлечённые факты/обещания должны **привязываться к людям и проектам**:
  - ссылка на `People/...` (кто сказал/кому адресовано),
  - ссылка на `Projects/...` (в рамках какого проекта),
  - хранить обратные связи (из карточки человека/проекта видно связанные факты и встречи).

### 3.4. Эмоциональная окраска
Требования:
- Оценка тона:
  - по участникам (реплики),
  - по всему разговору.
- Метрики: нейтральный/напряжённый/позитивный и т.п. (настраиваемый набор).

### 3.5. Участники + “слепок голоса” (voiceprint)
Требования:
- Извлекать список участников:
  - из календаря (attendees),
  - из речи/обращений (если возможно),
  - вручную подтвердить/исправить в UI.
- Делать “слепок голоса” для каждого участника, чтобы позже определять автоматически.
  - хранить безопасно (хэш/эмбеддинг), версионировать.
  - предусмотреть согласие/конфиденциальность (важно).

---

## 4) Ведение карточек (люди / проекты)

### 4.1. Карточка (структура)
Требования:
- На карточке человека хранить:
  - базовые данные (имя, компания, роли),
  - контакты (может быть несколько значений каждого типа):
    - телефоны (личный/рабочий/другое),
    - email (личный/рабочий),
    - ссылки (LinkedIn/Telegram/сайт/портфолио),
    - ссылка/ссылки на резюме (CV),
  - “досье” (сводка),
  - связи (проекты/встречи),
  - извлечённые факты/обещания/конфликты/интересы.
- Формат: markdown-файл в vault + frontmatter (YAML) для ключевых полей.

### 4.2. Хранение “хэшей голоса”
Требования:
- Хранить voiceprint для автодетекта.
- Привязка voiceprint ↔ карточка человека.
- Возможность обновлять/объединять/удалять voiceprint.

### 4.3. Обогащение из внешних и закрытых источников
Требования:
- Уметь “обогащать” карточку:
  - ручной импорт (текст/ссылки),
  - интеграции (в будущем) — CRM, почта, мессенджеры, приватные базы.
- Важно: фиксировать источники и дату обновления.

### 4.4. Карточка проекта (структура и сценарии)
Требования:
- Карточка проекта хранит:
  - цель/описание проекта,
  - статус (idea/active/on-hold/done), приоритет,
  - ключевые участники (ссылки на People),
  - встречи и протоколы (ссылки на Protocols/Calendar),
  - решения, договорённости, обещания (с источниками и датами),
  - факты/риски/следующие шаги.
- Формат: markdown-файл в vault + frontmatter (YAML) для ключевых полей.
- Сценарии:
  - из заметки встречи можно “привязать к проекту” (выбор существующего или создание нового),
  - проектная сводка строится из связанных встреч/фактов (как “хронология”).

---

## 5) Настройки (Settings UI)

### 5.0. Папки в vault (настраиваемые)
Требования:
- В настройках должно быть управление папками хранения (по умолчанию во множественном числе):
  - `Ассистент/Логи/`
  - `Ассистент/Встречи/`
  - `Ассистент/Протоколы/`
  - `Ассистент/Люди/`
  - `Ассистент/Проекты/`
- Эти пути должны быть **настраиваемыми**, т.к. пользователь может захотеть другой layout vault.

### 5.1. Календарь
- Подключения: список календарей.
- Политики синхронизации: период, частота, кеширование, оффлайн.
- Уведомления: “за N минут”, “в момент начала”, DND.
- Автообновление:
  - включить/выключить,
  - интервал (например, каждые 5/10/15/30 минут),
  - ручная кнопка “Обновить сейчас”.

### 5.2. Запись
- Вкл/выкл детект встреч.
- Источник детекта: процессы / аудио / гибрид.
- Автостарт записи: вкл/выкл, таймер.
- Интеграция с “Диктофон”: выбор режима (если доступно).

### 5.3. Транскрибация/AI
- Провайдер: локально / облако.
- Язык(и).
- Форматы вывода: транскрипт/саммари/факты/эмоции.
- Интеграция с Obsidian Copilot (если доступно): использовать как движок/провайдера (через его API или через общие файлы/команды).

---

## 6) Данные и хранение

### 6.1. Где хранить
- **Obsidian vault**: markdown заметки (встречи/протоколы/люди/проекты).
- **Папка плагина**: технические файлы (кеш календарей, индексы, voiceprint, настройки).

### 6.1.1. Приватность и локальность (нефункциональные требования)
Требования:
- Vault синхронизируется через **приватный git-репозиторий** (и доступен на телефоне).
- На старте допускается **облачная обработка** (AI/ASR/voiceprint) — всё должно быть явным: провайдер, ключи, что отправляется, логирование, возможность отключить.
- В перспективе возможен переход на **локальную обработку** (время/опыт покажет).
- Учитывать git-sync → не складывать тяжёлые бинарники в git без необходимости.

### 6.2. Политика хранения записей (аудио)
Требования:
- После успешной обработки записи (получены: транскрипт, тайминги, спикеры/voiceprint, факты/саммари и т.д.) **аудиофайл можно удалять**.
- Должны быть настройки ретенции:
  - “Удалять аудио сразу после успешной обработки” (по умолчанию: **вкл**),
  - “Хранить N дней” (опционально),
  - “Никогда не удалять” (если нужно для контроля качества).
- В заметке протокола хранить:
  - метаданные обработки,
  - ссылки на результаты,
  - (опционально) путь к аудио, если оно не удалено.

### 6.3. Git-синхронизация (важно)
Требования:
- Vault синхронизируется через **приватный git**, но аудиофайлы записей всё равно **желательно не коммитить** (большие бинарники).
- Рекомендуемые стратегии:
  - хранить записи **вне vault** (в папке плагина/вне git), а в vault сохранять только транскрипт/саммари/факты;
  - или хранить временно и удалять после обработки (см. 6.2).

### 6.4. Предлагаемая структура в vault (черновик)
- `Meetings/` — встречи (по дате).
- `People/` — карточки людей.
- `Projects/` — карточки проектов.
- `Calendar/` — заметки встреч (опционально).

Также для плагина создаются папки (внутри vault) — **по умолчанию** (и это настраивается в Settings):
- `Ассистент/Логи/` — логи по датам (md файлы).
- `Ассистент/Встречи/` — встречи календаря (md файлы). Клик по встрече в “Повестке” открывает файл встречи.
  - Повторяющиеся встречи (например “Планёрка”) живут **в одном файле** (стабильно по `event_key = calendar_id:uid`).
- `Ассистент/Люди/` — карточки людей (md файлы).
- `Ассистент/Проекты/` — карточки проектов (md файлы).
- `Ассистент/Протоколы/` — протоколы конкретных встреч (md файлы), например “Планёрка 19 января”.

### 6.5. Сущности и связи (база данных в markdown)
Модель:
- **Встреча (Calendar Event)** → хранится в `Ассистент/Встречи/` (1 запись = 1 “тип” встречи, включая повторяющиеся по UID).
- **Протокол (Protocol)** → хранится в `Ассистент/Протоколы/` (каждая конкретная встреча: “Планёрка 19 января”).
- **Связь**: **Встреча 1 → N Протоколов** (одна встреча может иметь много протоколов).
- **Из протокола извлекаются**: **Люди** (`Ассистент/Люди/`) и **Проекты** (`Ассистент/Проекты/`).

Правила:
- При **обновлении календарей** плагин **не должен создавать прошедшие** встречи в `Ассистент/Встречи/` (чтобы не засорять vault).
- Исключение: если пользователь **перешёл во встречу из UI** (клик по встрече) — файл встречи может быть создан **on-demand** даже для прошедшей даты.
- В файле встречи должна быть секция **“Протоколы”** со ссылками на связанные заметки протоколов.
- В заметке протокола должны быть: ссылка на запись (если есть), транскрипт, саммари (несколько форматов), извлечённые факты/обещания/задачи и ссылки на людей/проекты.

Правила именования файлов:
- Файлы **встреч** должны быть:
  - **человекочитаемые** (название встречи в начале),
  - но при этом **стабильные** при переименовании встречи.
  - Практика: имя файла = `"{summary} [{sid}].md"`, где:
    - `event_key = calendar_id:uid` (хранится в frontmatter),
    - `sid` — короткий стабильный идентификатор, вычисляемый из `event_key` (в имени файла вместо `uid/calendar_id`).
  - При изменении `summary` плагин может **переименовать файл** (оставляя тот же `[sid]`), чтобы имя оставалось красивым.
- Файлы **протоколов** должны иметь **человекочитаемые имена** (с пробелами), например: “Техническая встреча с Партнёром”.
- В имени файла **не используем** `uid` и `calendar_id` (используем `[sid]`).
- В свойствах (frontmatter) протокола обязательно хранить:
  - `uid`
  - `calendar_id`
- Если имя файла конфликтует (файл уже существует) — добавлять суффикс: ` 2`, ` 3`, ` 4` и т.д.

---

## 7) Архитектура (важно для реальности)

### 7.0. Разделение слоёв (Sync vs UI)
Требования:
- UI (повестка/лог) не должен содержать “тяжёлую” логику синхронизации.
- Синхронизация календарей, запись в vault, планирование уведомлений — отдельный слой (например `SyncService`), чтобы:
  - проще тестировать,
  - проще расширять (встречи/люди/проекты),
  - ошибки синка не ломали UI.

### 7.1. Что можно сделать чисто в Obsidian-плагине
- UI панели календаря.
- Планировщик уведомлений по синхронизированным встречам.
- Создание/обновление заметок в vault.
- Вызов AI через HTTP (если есть ключи/endpoint) или через локальный сервис.
- Панель “Лог” (внутренние записи плагина).

### 7.2. AI-стек (локально/облако) и интеграция с Copilot
Требования:
- На старте используется **облачный AI-стек** (быстрее запустить).
- Позже (если будет смысл) добавить **локальные модели**:
  - Ollama (локальный inference),
  - или LM Studio (локальный OpenAI-совместимый сервер).
- Должна быть возможность использовать **единый OpenAI-compatible endpoint** (например, Continue server или аналог) для:
  - Obsidian (через Copilot),
  - IDE/CLI (вне плагина).
- В ТЗ это отражаем как “провайдер AI”:
  - `local-openai-compatible` (localhost),
  - `cloud-openai-compatible` (опционально).

### 7.2. Что требует внешнего компонента (helper)
Для Linux (в текущем scope) надёжно:
- список активных приложений/окон/URL вкладки,
- доступ к аудиоустройствам/детект речи,
- запись системного аудио/микрофона (устойчиво),
- voiceprint/спикер-диаризация (часто через ML-библиотеки).

Решение:
- локальный **helper-сервис** (демон) + простой протокол:
  - `GET /status` (есть ли встреча),
  - `POST /record/start|stop`,
  - `POST /transcribe`,
  - `GET /devices`,
  - `GET /processes` (опционально).

### 7.3. Офлайн-встречи и мобильный сценарий
Требования:
- Должен быть сценарий **офлайн-встреч** (не Zoom/Meet): запись с микрофона/телефона.
- На телефоне есть vault (git-sync), поэтому возможен поток:
  - **запись на телефоне** (в vault или рядом),
  - **синхронизация через git**,
  - **обработка на компьютере** после синхронизации (саммари/факты/участники/привязки).

### 7.4. Внешние сервисы на старте (ASR/voiceprint)
Требования:
- Скорее всего на старте для:
  - распознавания речи (ASR),
  - диаризации/спикеров,
  - “слепков голоса” (voiceprint),
используются **внешние сервисы**, а затем возможен переход на локальные решения (по мере опыта/готовности).

---

## 8) MVP-этапы (рекомендуемый порядок)

### MVP-0 ✅
- Команда и pop-up в Obsidian.

### MVP-1: Календарь (минимально)
- Подключение через ICS URL (самый простой старт).
- Панель “Повестка”.
- Уведомления за 5 минут и в момент начала.
- Автообновление календарей по интервалу.
- Панель “Лог” (минимально: обновили календари/показали уведомление/ошибка).

### MVP-2: Запись (минимально)
- Только ручной старт записи (кнопка в попапе/команда).
- Сохранение аудио + создание заметки встречи.

### MVP-3: Транскрибация (минимально)
- Один провайдер (например, локальный или облачный) + генерация заметки с транскриптом и саммари.

### MVP-4: Люди
- Карточки людей + ручное связывание с репликами/встречами.

### MVP-5: Тактический/стратегический слой
- Сбор задач/обещаний из встреч в проекты.
- Базовые отчёты/планы (оперативные/тактические/стратегические) на базе Obsidian.

---

## 9) Первые задачи для реализации в этом репозитории

1) Добавить Settings-экран (пока stub) + хранение настроек.
2) Добавить “Calendar: ICS URL” (скачивание + парсинг + кеш).
3) Добавить View “Agenda”.
4) Добавить планировщик уведомлений (5 минут/старт).
5) Добавить сущность “Protocol note” и базовый шаблон заметки.
6) Добавить сущность “Project note” (шаблон) + привязку Protocol → Project (минимально: поле/ссылка).
7) Добавить настройки “AI provider” (локальный OpenAI-compatible endpoint) и сохранение параметров провайдера.

# Заметки

- [ ] Отмечать встречи Да (Да в переговорке, да виртуально) / Нет / Может быть / Нет выбора (Одно или и последующие события)
- [ ] Визуально что бы встречи отличались от Приду / Не приду / ...
- [ ] Визуально цветные события (Метки)
- [ ] Отметка кто придет кто нет
- [ ] Название встречи хочется сделать человеческим, при дублях суфикс 1,2,3... Что встречах что в 
- [ ] Из календаря, извлечение информации об участниках в карточки
- [ ] Кэширование данных календаря, например если нет сети, то будешь видеть послендние данные, в логах должно быть видно что не ссмогли получить данные
- [ ] Офлайн режим, точнее все изменения (Приду на встречу) не пытаться сделать сразу, а складывать в очередь. А из очерезди брать изменения и применять их. Если не возможно писать в лог.
- [ ] Алерт напоминание сделать красивым через WebView (если есть обсидиан то есть и хром) как окно настроект обсидиана что бы не смотрелось костылем. Можно добавить чуть чуть прозразчности.
- [ ] Детектирование звука и запущенногго софта (Zoom) и алерт с предложение записи, с выбором встречи и ли указания что встреча не из календаря. (Обратный отсчет для начала)
- [ ] Запись звука, продумать по хорошему сделать отдельными файлами по N минут, что бы уже во время встречи получать рассшифровку, факты, проекты и т.д. Главное не дожидаться окончания.
- [ ] Окно записи встречи со статистикой (Длительность, записанно файлов, распознанно файлов, найдено проектов, фактов, распознано людей, анонимных людей и т.д.)
- [ ] Логи вынести в системную папку /home/gernovich/notes/.obsidian/plugins/assistant/logs
