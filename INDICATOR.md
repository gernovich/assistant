# Индикатор записи (осциллограмма/уровень) — заметки по эволюции

Документ фиксирует, **что пробовали**, **что в итоге работает**, и **какие хвосты/риски** остались по “индикатору” в диктофоне.

## Цель индикатора

- **Показывать живую активность звука** во время записи (чтобы понимать “пишется ли вообще”).
- Для **Linux Native** индикатор должен отражать **итоговый микс mic + system (monitor)**.
- UX‑цель: визуализация должна быть **плавной**, с “окном” примерно **10 секунд**, и начинаться визуально “из кнопки REC”.

## Где реализовано

- UI / canvas: `src/recording/recordingDialog.ts`
- Захват/метрики: `src/recording/recordingService.ts`

## Что пробовали (по порядку)

### 1) WebAudio/AnalyserNode (Electron backend)

- **Подход**: `AudioContext + AnalyserNode`, RMS по time-domain данным.
- **Результат**: работает “из коробки”, плавно, т.к. это локальный поток WebAudio.
- **Минусы**: применимо только к `electron_desktop_capturer`/mic-стриму (не решает Linux Native).

### 2) ffmpeg `astats` / `ametadata=print` (Linux Native)

- **Подход**: пытались достать RMS/статистики через `astats` и печать метаданных в stderr.
- **Проблемы**:
  - в некоторых сборках/режимах полезные значения появлялись **только на завершение**;
  - `/dev/stderr` в окружении Obsidian/Electron давал проблемы → пришлось переходить на `pipe:2`.
- **Итог**: нестабильно как “живой” индикатор.

### 3) ffmpeg `ebur128=...:framelog=info` (Linux Native)

- **Подход**: парсить `M:` (momentary LUFS) из stderr.
- **Плюсы**: метрики на итоговом миксе, меньше зависимости от `astats`.
- **Проблемы**:
  - вывод может идти через `\r`/пачками → требовался более устойчивый split/parsing;
  - частота/равномерность строк **не гарантируется**, поэтому UI выглядел “рваным”.
- **Итог**: как fallback‑метод — ок, но “как раньше” по плавности не даёт.

### 4) Linux Native: чтение PCM из ffmpeg stdout (текущий основной путь)

- **Подход**: ffmpeg продолжает писать файл (opus/ogg), а для визуализации дополнительно отдаёт **raw PCM** в `stdout`:
  - микс → downsample до 8kHz → mono → фиксированные блоки (кадры);
  - в Node считаем RMS → переводим в 0..1 → шлём в UI.
- **Зачем**: получить “реальные сэмплы” (как WebAudio), независимо от того, что ffmpeg пишет в лог.
- **Плюсы**:
  - визуализация не зависит от loglevel/буферизации stderr;
  - можно управлять частотой кадров (25/33/50мс).
- **Риски**:
  - дополнительный pipe в stdout (но объём небольшой: 8kHz mono s16).

## Ключевые проблемы, которые всплывали

### A) “Нет индикатора вообще”

Причины, которые встречались:

- canvas получал **нулевой/1×1 размер** (из‑за `BrowserWindow show:false` и раннего layout);
- неверная привязка координат “от кнопки” (считали от `.card`, надо от `canvas`).

Фиксы:

- повторные `resizeCanvas()` после показа + self-heal при `width<=2`;
- координаты startX считаются относительно `canvas.getBoundingClientRect()`.

### B) “Индикатор обновляется раз в секунду”

Причина:

- на каждую метрику делали `webContents.executeJavaScript(...)` → очередь забивалась, визуально превращалось в ~1fps.

Фикс:

- батчинг доставки: хранить последнее значение и пушить в окно таймером (30fps), с **drop frames** если вызов ещё выполняется.

### C) “График дёргается / редкие обновления / квадраты”

Причина:

- даже при PCM, окно может получать апдейты редко/пачками; если писать точки только “по событию”, получается ступенчатость.

Фикс:

- в UI `__assistantRecordingVizUpdate` сохраняет **target**, а точки для графика заполняются **равномерно по времени** в `requestAnimationFrame` (с интерполяцией/инерцией).

### D) “Высота низкая / почти плоско”

Причина:

- линейный RMS даёт маленькие значения на обычной речи.

Фикс:

- маппинг RMS → **dBFS** → 0..1 (диапазон около `-60..-12 dBFS`) + лёгкая гамма‑коррекция при отрисовке.

### E) “Stop давал SIGKILL и 0‑байт файл”

Причина:

- завершали ffmpeg слишком жёстко/быстро (SIGKILL), не давая дописать контейнер.

Фиксы:

- ffmpeg запускается со `stdin: pipe`;
- stop отправляет `q` в stdin (штатный graceful stop), даёт больше времени на flush;
- SIGKILL только как последний fallback.

## Текущее состояние (на сейчас)

- Linux Native визуализация берётся **из PCM** потока, который отдаёт ffmpeg в stdout.
- UI рисует последние **~10 секунд** по timestamp, старт “из кнопки”.
- Визуализация должна оставаться плавной даже при “неровной” доставке значений.

## Оставшиеся хвосты / риски

- **Производительность UI**: canvas + rAF должны быть лёгкими; если начнутся лаги — снижать частоту fill (например 33мс вместо 16мс) или упрощать отрисовку.
- **Аудио-уровни**: маппинг dBFS субъективен; может потребоваться калибровка (например диапазон `-70..-10`) под реальные встречи.
- **Стабильность ffmpeg stdout**: теоретически возможны ситуации, когда stdout блокируется; мы стараемся держать кадры маленькими, но при проблемах — fallback на ebur128.

## Быстрая диагностика (что смотреть в логах)

- `Linux Native: ffmpeg spawn ... -map [viz] ... pipe:1` — включился PCM‑режим.
- `Linux Native: meter rate (pcm) {hz: ...}` — реальная частота кадров визуализации.
- `Viz: amp01=...` — значения доходят до окна (диагностика “путь живой”).
